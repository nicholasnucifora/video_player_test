<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vidstack Player Playground</title>
  <link rel="modulepreload" href="https://cdn.vidstack.io/player" />
  <link rel="preload" href="https://cdn.vidstack.io/player/theme.css" as="style" />
  <link rel="preload" href="https://cdn.vidstack.io/player/video.css" as="style" />
  <link rel="stylesheet" href="https://cdn.vidstack.io/player/theme.css" />
  <link rel="stylesheet" href="https://cdn.vidstack.io/player/video.css" />
  <link rel="preconnect" href="https://www.youtube.com" />
  <link rel="preconnect" href="https://i.ytimg.com" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0f0f0f; color: #fff; font-family: system-ui, -apple-system, sans-serif; min-height: 100vh; }

    /* ‚îÄ‚îÄ Theatre layout ‚îÄ‚îÄ */
    .theatre-row { display: flex; width: 100%; background: #000; height: 100vh; max-height: 100vh; overflow: hidden; }
    .player-col { flex: 1; min-width: 0; position: relative; background: #000; overflow: hidden; }
    media-player { width: 100%; height: 100%; display: block; }
    media-player video, media-player iframe { object-fit: contain !important; }

    /* ‚îÄ‚îÄ Side panel (shared by chapters + comments) ‚îÄ‚îÄ */
    .side-panel { position: absolute; right: 0; top: 0; bottom: 0; width: 0; overflow: hidden; background: #1a1a1a; border-left: 1px solid #2a2a2a; transition: width 0.3s ease; display: flex; flex-direction: column; z-index: 100; box-shadow: -4px 0 24px rgba(0,0,0,0.4); }
    .side-panel.open { width: 540px; }
    .side-panel-header { display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid #2a2a2a; flex-shrink: 0; }
    .side-panel-header h3 { font-size: 1.1rem; font-weight: 600; color: #fff; }
    .side-panel-close { appearance: none; border: none; background: none; color: #aaa; cursor: pointer; padding: 4px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: background 0.15s, color 0.15s; }
    .side-panel-close:hover { background: #333; color: #fff; }
    .side-panel-close svg { width: 20px; height: 20px; }
    .side-panel-body { flex: 1; overflow-y: auto; padding: 8px 0; }
    .side-panel-body::-webkit-scrollbar { width: 6px; }
    .side-panel-body::-webkit-scrollbar-track { background: transparent; }
    .side-panel-body::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }

    /* Panel tabs (chapters vs comments) */
    .panel-content { display: none; }
    .panel-content.active { display: block; }

    /* ‚îÄ‚îÄ Chapters ‚îÄ‚îÄ */
    .chapter-item { display: flex; gap: 16px; align-items: flex-start; padding: 16px 20px; cursor: pointer; transition: background 0.15s; border-left: 4px solid transparent; margin-bottom: 4px; }
    .chapter-item:hover { background: #252525; }
    .chapter-item.active { background: rgba(59,130,246,0.15); border-left-color: #3b82f6; }
    .chapter-item.active .chapter-label { color: #fff; font-weight: 600; }
    .chapter-item.active .chapter-time { color: #3b82f6; }
    .chapter-thumb { width: 160px; height: 90px; border-radius: 8px; object-fit: cover; flex-shrink: 0; background: #333; }
    .chapter-info { flex: 1; min-width: 0; }
    .chapter-info .chapter-label { font-size: 1.2rem; font-weight: 500; color: #eee; line-height: 1.4; margin-bottom: 6px; }
    .chapter-info .chapter-time { font-size: 1.1rem; color: #888; font-variant-numeric: tabular-nums; }

    /* ‚îÄ‚îÄ Kill only Vidstack's chapters DROPDOWN (keep the button itself visible) ‚îÄ‚îÄ */
    .vds-chapters-menu-items, .vds-chapters-radio-group, media-menu-items[class*="chapter"] { display: none !important; height: 0 !important; overflow: hidden !important; pointer-events: none !important; }
    /* Hide the popup/flyout but NOT the trigger button */
    .vds-chapters-menu .vds-menu-items, .vds-chapters-menu [part="items"], .vds-chapters-menu media-menu-items { display: none !important; height: 0 !important; overflow: hidden !important; pointer-events: none !important; }

    /* ‚îÄ‚îÄ Below-player ‚îÄ‚îÄ */
    .below-player { max-width: 100%; margin: 0; padding: 1.5rem 3rem 3rem; }

    /* ‚îÄ‚îÄ Fullscreen ‚îÄ‚îÄ */
    .fullscreen-wrapper { position: relative; background: #000; }
    .fullscreen-wrapper:fullscreen { overflow-y: auto; background: #0f0f0f; }
    .fullscreen-wrapper:fullscreen .theatre-row { height: 100vh; }
    .fullscreen-wrapper:fullscreen media-player { height: 100vh; }
    .fs-content { display: none; padding: 1.5rem 2rem 3rem; max-width: 800px; margin: 0 auto; }
    .fullscreen-wrapper:fullscreen .fs-content { display: block; }

    /* ‚îÄ‚îÄ Video info ‚îÄ‚îÄ */
    .video-info { margin-bottom: 2rem; }
    .video-info .video-title { font-size: 2rem; font-weight: 600; margin-bottom: 1rem; line-height: 1.35; }
    .channel-row { display: flex; align-items: center; gap: 16px; margin-bottom: 1.25rem; }
    .channel-row img { width: 52px; height: 52px; border-radius: 50%; object-fit: cover; }
    .channel-row .channel-name { font-weight: 600; font-size: 1.3rem; }
    .description-box { background: #1a1a1a; border-radius: 12px; padding: 1rem 1.25rem; cursor: pointer; transition: background 0.15s; }
    .description-box:hover { background: #222; }
    .description-box .desc-preview { font-size: 1.15rem; color: #aaa; line-height: 1.6; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .description-box.expanded .desc-preview { -webkit-line-clamp: unset; white-space: pre-wrap; }
    .description-box .desc-toggle { font-size: 1.05rem; color: #888; margin-top: 6px; }

    /* ‚îÄ‚îÄ Comments with thread lines ‚îÄ‚îÄ */
    .comments-section h2 { font-size: 1.6rem; margin-bottom: 1.25rem; font-weight: 600; }
    .comment-thread { position: relative; padding-left: 0; }
    .comment-main { display: flex; gap: 16px; padding: 14px 0; }
    .comment-main img { width: 48px; height: 48px; border-radius: 50%; object-fit: cover; flex-shrink: 0; }
    .comment-main .comment-body { flex: 1; min-width: 0; }
    .comment-main .author { font-weight: 600; font-size: 1.15rem; margin-bottom: 4px; color: #eee; }
    .comment-main .text { font-size: 1.15rem; color: #ccc; line-height: 1.6; word-wrap: break-word; }
    .comment-main .meta { font-size: 1rem; color: #666; margin-top: 8px; display: flex; align-items: center; gap: 14px; }

    /* Comment text truncation ‚Äî 5 lines max, expandable */
    .comment-main .text.truncated { display: -webkit-box; -webkit-line-clamp: 5; -webkit-box-orient: vertical; overflow: hidden; }
    .comment-main .text.truncated.expanded { -webkit-line-clamp: unset; }
    .read-more-btn { appearance: none; border: none; background: none; color: #aaa; font-size: 1rem; font-weight: 500; cursor: pointer; padding: 4px 0; margin-top: 4px; transition: color 0.15s; }
    .read-more-btn:hover { color: #fff; }

    /* Thread line ‚Äî connects parent avatar to replies when expanded */
    .comment-thread { position: relative; }
    .comment-thread .thread-line { display: none; }

    /* Stem line from parent avatar down to replies ‚Äî real DOM element for hover interaction */
    /* Height is set dynamically via JS to reach exactly to the replies container top */
    .thread-stem { display: none; position: absolute; left: 24px; top: 58px; width: 20px; cursor: pointer; z-index: 1; }
    .thread-stem::after { content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 2px; background: #333; transition: background 0.15s; }
    .comment-thread.has-replies-open .thread-stem { display: block; }
    /* Also show stem when collapsed (to connect "Show X replies" to avatar) */
    .comment-thread.has-replies .thread-stem { display: block; }
    /* Hover on stem OR collapse line highlights the whole tree */
    .comment-thread.thread-hover .thread-stem::after,
    .comment-thread.thread-hover .replies-collapse-line::after { background: #888; }
    .comment-thread.thread-hover .replies-toggle-top::after,
    .comment-thread.thread-hover .reply-wrapper::after,
    .comment-thread.thread-hover .replies-toggle-bottom::after { border-color: #888; }

    /* Top "Show X replies" toggle ‚Äî tree item with L-curve from the stem */
    .replies-toggle-top { position: relative; appearance: none; border: none; background: none; color: #93b3e6; font-size: 1.1rem; font-weight: 600; cursor: pointer; padding: 8px 12px 8px 22px; display: flex; align-items: center; gap: 6px; transition: background 0.15s; margin-top: 2px; margin-left: 24px; border-radius: 20px; }
    .replies-toggle-top::after { content: ''; position: absolute; left: 0; top: 2px; width: 14px; height: 16px; border-left: 2px solid #333; border-bottom: 2px solid #333; border-radius: 0 0 0 12px; background: transparent; }
    .replies-toggle-top:hover { background: rgba(147,179,230,0.1); }

    /* Replies container ‚Äî indented so the collapse line aligns under parent avatar center */
    .replies-container { margin-left: 24px; display: none; position: relative; }
    .replies-container.show { display: block; }

    /* Clickable collapse line inside the replies container ‚Äî stops before bottom toggle via bottom offset */
    .replies-collapse-line { position: absolute; left: 0; top: 0; bottom: 22px; width: 20px; cursor: pointer; z-index: 2; }
    .replies-collapse-line::after { content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 2px; background: #333; border-radius: 1px; transition: background 0.15s; }

    /* Individual reply ‚Äî L-curve connects collapse line to reply avatar */
    .reply-wrapper { position: relative; padding-left: 22px; min-height: 32px; }
    .reply-wrapper::after { content: ''; position: absolute; left: 0; top: 0; width: 14px; height: 18px; border-left: 2px solid #333; border-bottom: 2px solid #333; border-radius: 0 0 0 12px; background: transparent; }
    .reply-wrapper .comment-main { padding: 4px 0 8px; }
    .reply-wrapper .comment-main img { width: 36px; height: 36px; }

    /* Sub-thread stem ‚Äî connects reply avatar down to sub-replies when expanded */
    /* Height set dynamically via JS */
    /* Sub-thread stem ‚Äî connects reply avatar down to sub-replies when expanded */
    /* left = padding-left (22px) + half avatar (14px) = 36px from wrapper edge = aligned with reply avatar center */
    .reply-wrapper .subreply-stem { display: none; position: absolute; left: 40px; top: 38px; width: 20px; cursor: pointer; z-index: 1; }
    .reply-wrapper .subreply-stem::after { content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 2px; background: #333; transition: background 0.15s; }
    .reply-wrapper.has-subreplies-open .subreply-stem { display: block; }
    /* Also show stem when collapsed (to connect "Show Reply" to avatar) */
    .reply-wrapper.has-subreplies .subreply-stem { display: block; }
    /* Hover on sub-stem OR sub-collapse line highlights both */
    .reply-wrapper.subreply-hover .subreply-stem::after,
    .reply-wrapper.subreply-hover .subreplies-collapse-line::after { background: #888; }
    .reply-wrapper.subreply-hover .subreply-toggle::after,
    .reply-wrapper.subreply-hover .subreply-toggle-bottom::after,
    .reply-wrapper.subreply-hover .subreply-item::after { border-color: #888; }

    /* Bottom "Hide replies" toggle ‚Äî last item in the tree, gets its own L-curve */
    .replies-toggle-bottom { position: relative; padding-left: 22px; appearance: none; border: none; background: none; color: #93b3e6; font-size: 1.1rem; font-weight: 600; cursor: pointer; padding-top: 4px; padding-bottom: 8px; display: flex; align-items: center; border-radius: 20px; transition: background 0.15s; }
    .replies-toggle-bottom::after { content: ''; position: absolute; left: 0; top: 0; width: 14px; height: 14px; border-left: 2px solid #333; border-bottom: 2px solid #333; border-radius: 0 0 0 12px; background: transparent; }
    .replies-toggle-bottom:hover { background: rgba(147,179,230,0.1); }

    /* Sub-reply show/hide toggle ‚Äî indented to align L-curve with reply avatar center */
    /* margin-left: 14px puts the toggle's left:0 at 22+14=36px from wrapper = avatar center */
    .subreply-toggle { position: relative; margin-left: 18px; padding-left: 22px; appearance: none; border: none; background: none; color: #93b3e6; font-size: 1.1rem; font-weight: 600; cursor: pointer; padding-top: 4px; padding-bottom: 4px; display: flex; align-items: center; border-radius: 18px; transition: background 0.15s; }
    .subreply-toggle::after { content: ''; position: absolute; left: 0; top: 0; width: 14px; height: 14px; border-left: 2px solid #333; border-bottom: 2px solid #333; border-radius: 0 0 0 12px; background: transparent; }
    .subreply-toggle:hover { background: rgba(147,179,230,0.1); }

    /* Bottom sub-toggle ‚Äî inside subreplies-container (already indented), no extra margin */
    .subreply-toggle-bottom { position: relative; padding-left: 22px; appearance: none; border: none; background: none; color: #93b3e6; font-size: 1.1rem; font-weight: 600; cursor: pointer; padding-top: 4px; padding-bottom: 4px; display: flex; align-items: center; border-radius: 18px; transition: background 0.15s; }
    .subreply-toggle-bottom::after { content: ''; position: absolute; left: 0; top: 0; width: 14px; height: 14px; border-left: 2px solid #333; border-bottom: 2px solid #333; border-radius: 0 0 0 12px; background: transparent; }
    .subreply-toggle-bottom:hover { background: rgba(147,179,230,0.1); }

    /* Sub-replies nested under a specific reply */
    /* margin-left: 14px aligns the sub-collapse line (left:0) with reply avatar center */
    .subreplies-container { margin-left: 18px; display: none; position: relative; }
    .subreplies-container.show { display: block; }
    /* Sub-collapse line stops before the bottom sub-toggle */
    .subreplies-collapse-line { position: absolute; left: 0; top: 0; bottom: 20px; width: 20px; cursor: pointer; z-index: 2; }
    .subreplies-collapse-line::after { content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 2px; background: #333; border-radius: 1px; transition: background 0.15s; }
    .subreply-item { position: relative; padding-left: 22px; }
    .subreply-item::after { content: ''; position: absolute; left: 0; top: 0; width: 14px; height: 16px; border-left: 2px solid #333; border-bottom: 2px solid #333; border-radius: 0 0 0 12px; background: transparent; }
    .subreply-item .comment-main { padding: 4px 0 6px; }
    .subreply-item .comment-main img { width: 32px; height: 32px; }

    /* Reply @mention highlight */
    .reply-mention { color: #93b3e6; font-weight: 600; }

    /* Mobile chapters section (below video) */
    .mobile-chapters-section { display: none; margin-bottom: 1.5rem; }
    .mobile-chapters-section h3 { font-size: 1rem; font-weight: 600; margin-bottom: 0.75rem; }
    .mobile-chapters-list { display: flex; gap: 10px; overflow-x: auto; padding-bottom: 8px; -webkit-overflow-scrolling: touch; scrollbar-width: none; }
    .mobile-chapters-list::-webkit-scrollbar { display: none; }
    .mobile-chapter-chip { flex-shrink: 0; display: flex; flex-direction: column; align-items: center; gap: 6px; cursor: pointer; width: 140px; }
    .mobile-chapter-chip img { width: 140px; height: 79px; border-radius: 8px; object-fit: cover; background: #333; }
    .mobile-chapter-chip .chip-label { font-size: 0.78rem; color: #ccc; line-height: 1.3; text-align: center; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .mobile-chapter-chip .chip-time { font-size: 0.72rem; color: #888; font-variant-numeric: tabular-nums; }
    .mobile-chapter-chip.active { outline: 2px solid #3b82f6; outline-offset: 2px; border-radius: 8px; }
    .mobile-chapter-chip.active img { border-radius: 8px; }

    /* Links */
    .desc-preview a, .comment-main .text a, .panel-comment .text a { color: #93b3e6; text-decoration: none; }
    .desc-preview a:hover, .comment-main .text a:hover, .panel-comment .text a:hover { text-decoration: underline; color: #b3ccf5; }

    /* Load more */
    .load-more-btn { display: block; width: 100%; padding: 14px; margin-top: 16px; background: #1a1a1a; border: 1px solid #2a2a2a; border-radius: 10px; color: #aaa; font-size: 1rem; cursor: pointer; transition: background 0.15s, color 0.15s; }
    .load-more-btn:hover { background: #252525; color: #fff; }
    .load-more-btn:disabled { opacity: 0.5; cursor: default; }

    /* ‚îÄ‚îÄ Scroll hint ‚îÄ‚îÄ */
    .scroll-hint { display: none; position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); background: rgba(255,255,255,0.12); backdrop-filter: blur(6px); border-radius: 20px; padding: 6px 18px; font-size: 13px; color: #ccc; z-index: 100; cursor: pointer; animation: bounce 2s infinite; }
    .fullscreen-wrapper:fullscreen .scroll-hint { display: block; }
    @keyframes bounce { 0%, 100% { transform: translateX(-50%) translateY(0); } 50% { transform: translateX(-50%) translateY(-6px); } }

    /* ‚îÄ‚îÄ Disable Vidstack gestures ‚îÄ‚îÄ */
    media-gesture { display: none !important; pointer-events: none !important; }
    media-player [data-media-icon="play"], media-player .vds-play-button[class*="center"], [part~="center-play"] { display: none !important; }

    /* ‚îÄ‚îÄ Custom overlay buttons (glass, bottom-right above controls) ‚îÄ‚îÄ */
    .custom-actions {
      position: absolute; bottom: 52px; right: 12px;
      display: flex; gap: 6px; z-index: 50; pointer-events: auto;
      opacity: 0; transition: opacity 0.3s ease;
    }
    media-player[data-controls] .custom-actions { opacity: 1; }
    .custom-actions button {
      appearance: none; border: 1px solid rgba(255,255,255,0.08); border-radius: 8px;
      padding: 5px 12px; font-size: 11px; font-weight: 500; cursor: pointer;
      transition: opacity 0.2s, transform 0.15s, background 0.2s; line-height: 1;
      backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    .custom-actions button:hover { opacity: 0.9; transform: scale(1.05); }
    .custom-actions button:active { transform: scale(0.96); }
    .btn-save { background: rgba(255,255,255,0.08); color: rgba(255,255,255,0.7); }
    .btn-save:hover { background: rgba(255,255,255,0.14); color: #fff; }
    .btn-finish { background: rgba(255,255,255,0.08); color: rgba(255,255,255,0.7); }
    .btn-finish:hover { background: rgba(255,255,255,0.14); color: #fff; }

    /* ‚îÄ‚îÄ Flash overlay ‚îÄ‚îÄ */
    .play-pause-flash { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.5); z-index: 60; pointer-events: none; opacity: 0; transition: opacity 0.15s ease, transform 0.15s ease; }
    .play-pause-flash.visible { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    .play-pause-flash.fade-out { opacity: 0; transform: translate(-50%, -50%) scale(1.3); transition: opacity 0.5s ease, transform 0.5s ease; }
    .play-pause-flash svg { width: clamp(48px, 10vw, 72px); height: clamp(48px, 10vw, 72px); filter: drop-shadow(0 2px 12px rgba(0,0,0,0.5)); }

    /* ‚îÄ‚îÄ Mobile play/pause circle ‚îÄ‚îÄ */
    .mobile-play-btn { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 55; width: 56px; height: 56px; border-radius: 50%; border: none; cursor: pointer; background: rgba(0,0,0,0.55); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); box-shadow: 0 2px 16px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.08); align-items: center; justify-content: center; opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
    .mobile-play-btn svg { width: 28px; height: 28px; }
    .mobile-play-btn.show { opacity: 1; pointer-events: auto; display: flex; }

    /* ‚îÄ‚îÄ Side panel comments ‚îÄ‚îÄ */
    .panel-thread { padding: 0 16px; }
    .panel-thread .comment-main img { width: 36px; height: 36px; }
    .panel-thread .comment-main .author { font-size: 1rem; }
    .panel-thread .comment-main .text { font-size: 1rem; }
    .panel-thread .comment-main .meta { font-size: 0.9rem; }
    .panel-thread .reply-wrapper .comment-main img { width: 28px; height: 28px; }
    .panel-thread .subreply-item .comment-main img { width: 24px; height: 24px; }
    .panel-thread .replies-toggle-top,
    .panel-thread .replies-toggle-bottom,
    .panel-thread .subreply-toggle,
    .panel-thread .subreply-toggle-bottom { font-size: 0.95rem; }
    .panel-thread .read-more-btn { font-size: 0.9rem; }

    /* ‚îÄ‚îÄ Responsive ‚îÄ‚îÄ */
    @media (max-width: 768px) {
      .side-panel { display: none !important; }
      .theatre-row { height: auto; max-height: none; flex-direction: column; }
      media-player { aspect-ratio: 16/9; height: auto; }
      .mobile-chapters-section { display: block; }
      .custom-comments-btn { display: none !important; }
    }
    @media (max-width: 600px) {
      .custom-actions { bottom: 48px; right: 8px; gap: 4px; }
      .custom-actions button { padding: 4px 8px; font-size: 10px; }
    }
</style>
</head>
<body>
  <div class="fullscreen-wrapper" id="fullscreenWrapper">
    <div class="theatre-row" id="theatreRow">
      <div class="player-col">
        <media-player title="YouTube Video" src="youtube/YFjfBk8HI5o" poster="https://i.ytimg.com/vi/YFjfBk8HI5o/maxresdefault.jpg" crossorigin playsinline load="eager">
          <media-provider></media-provider>
          <media-video-layout></media-video-layout>

          <div class="custom-actions">
            <button class="btn-save" id="saveBtn" type="button">Save Progress</button>
            <button class="btn-finish" id="finishBtn" type="button">Finish</button>
          </div>
          <div class="play-pause-flash" id="playPauseFlash"></div>
          <button class="mobile-play-btn" id="mobilePlayBtn" type="button" aria-label="Play/Pause">
            <svg class="mobile-play-icon" viewBox="0 0 24 24" fill="white"><path d="M8 5v14l11-7z"/></svg>
            <svg class="mobile-pause-icon" viewBox="0 0 24 24" fill="white" style="display:none"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
          </button>

          <!-- Side panel lives inside media-player so it's visible in Vidstack's native fullscreen -->
          <div class="side-panel" id="sidePanel">
            <div class="side-panel-header">
              <h3 id="sidePanelTitle">In this video</h3>
              <button class="side-panel-close" id="sidePanelClose" type="button" aria-label="Close panel">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
              </button>
            </div>
            <div class="side-panel-body">
              <div class="panel-content active" id="panelChapters"></div>
              <div class="panel-content" id="panelComments"></div>
            </div>
          </div>
        </media-player>
      </div>
    </div>
    <div class="fs-content"></div>
    <div class="scroll-hint" id="scrollHint">‚Üì Scroll for comments</div>
  </div>

  <div class="below-player">
    <div class="video-info" id="videoInfo">
      <div class="video-title" id="videoTitle">Loading...</div>
      <div class="channel-row" id="channelRow" style="display:none;">
        <img id="channelAvatar" src="" alt="Channel avatar" />
        <span class="channel-name" id="channelName"></span>
      </div>
      <div class="description-box" id="descBox">
        <div class="desc-preview" id="descText"></div>
        <div class="desc-toggle" id="descToggle">Show more</div>
      </div>
    </div>
    <div class="mobile-chapters-section" id="mobileChapters">
      <h3>Chapters</h3>
      <div class="mobile-chapters-list" id="mobileChaptersList"></div>
    </div>
    <div class="comments-section">
      <h2 id="commentsHeading">Comments</h2>
      <div id="commentsList"></div>
    </div>
  </div>

  <script type="module" src="https://cdn.vidstack.io/player"></script>
  <script>
    const VIDEO_ID = 'YFjfBk8HI5o';
    const isMobile = () => window.matchMedia('(pointer: coarse)').matches;

    // ‚îÄ‚îÄ Side panel (shared chapters + comments) ‚îÄ‚îÄ
    const sidePanel = document.getElementById('sidePanel');
    const sidePanelTitle = document.getElementById('sidePanelTitle');
    const panelChapters = document.getElementById('panelChapters');
    const panelComments = document.getElementById('panelComments');
    let currentPanel = null; // 'chapters' | 'comments' | null

    function openPanel(type) {
      // On mobile, chapters are already below the video ‚Äî only comments use the scroll-to approach
      if (isMobile()) {
        if (type === 'comments') {
          const commentsSection = document.querySelector('.comments-section');
          if (commentsSection) commentsSection.scrollIntoView({ behavior: 'smooth' });
        } else if (type === 'chapters') {
          const mobileChapters = document.getElementById('mobileChapters');
          if (mobileChapters) mobileChapters.scrollIntoView({ behavior: 'smooth' });
        }
        return;
      }
      if (currentPanel === type) { closePanel(); return; }
      currentPanel = type;
      sidePanel.classList.add('open');
      if (type === 'chapters') {
        sidePanelTitle.textContent = 'In this video';
        panelChapters.classList.add('active');
        panelComments.classList.remove('active');
      } else {
        sidePanelTitle.textContent = 'Comments';
        panelComments.classList.add('active');
        panelChapters.classList.remove('active');
        if (!panelComments.hasChildNodes()) populatePanelComments();
      }
    }

    function closePanel() {
      sidePanel.classList.remove('open');
      currentPanel = null;
    }

    document.getElementById('sidePanelClose').addEventListener('click', closePanel);

    // ‚îÄ‚îÄ Button handlers ‚îÄ‚îÄ
    document.getElementById('saveBtn').addEventListener('click', (e) => {
      e.stopPropagation();
      const player = document.querySelector('media-player');
      const time = player?.currentTime ?? 0;
      alert(`Progress saved at ${new Date(time * 1000).toISOString().substring(11, 19)}`);
    });
    document.getElementById('finishBtn').addEventListener('click', (e) => {
      e.stopPropagation();
      if (confirm('Mark this video as finished?')) alert('Video marked as finished!');
    });

    // ‚îÄ‚îÄ Description expand/collapse ‚îÄ‚îÄ
    document.getElementById('descBox').addEventListener('click', () => {
      const box = document.getElementById('descBox');
      const toggle = document.getElementById('descToggle');
      box.classList.toggle('expanded');
      toggle.textContent = box.classList.contains('expanded') ? 'Show less' : 'Show more';
    });

    // ‚îÄ‚îÄ Player logic ‚îÄ‚îÄ
    document.addEventListener('DOMContentLoaded', () => {
      customElements.whenDefined('media-player').then(() => {
        const player = document.querySelector('media-player');
        const wrapper = document.getElementById('fullscreenWrapper');
        const flash = document.getElementById('playPauseFlash');
        const mobileBtn = document.getElementById('mobilePlayBtn');
        const mobilePlayIcon = mobileBtn.querySelector('.mobile-play-icon');
        const mobilePauseIcon = mobileBtn.querySelector('.mobile-pause-icon');

        const playSVG = `<svg viewBox="0 0 24 24" fill="white"><path d="M8 5v14l11-7z"/></svg>`;
        const pauseSVG = `<svg viewBox="0 0 24 24" fill="white"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>`;

        let flashTimer = null;
        function showFlash(isPlaying) {
          flash.innerHTML = isPlaying ? pauseSVG : playSVG;
          flash.classList.remove('fade-out'); flash.classList.add('visible');
          clearTimeout(flashTimer);
          flashTimer = setTimeout(() => { flash.classList.remove('visible'); flash.classList.add('fade-out'); }, 300);
        }

        function togglePlay() { if (player.paused) player.play(); else player.pause(); }

        function updateMobileIcon() {
          mobilePlayIcon.style.display = player.paused ? '' : 'none';
          mobilePauseIcon.style.display = player.paused ? 'none' : '';
        }
        player.addEventListener('play', updateMobileIcon);
        player.addEventListener('pause', updateMobileIcon);

        // Track active chapter
        player.addEventListener('timeupdate', () => {
          const time = player.currentTime;
          document.querySelectorAll('.chapter-item').forEach(item => {
            const start = parseFloat(item.dataset.start), end = parseFloat(item.dataset.end);
            const wasActive = item.classList.contains('active');
            const isActive = time >= start && time < end;
            item.classList.toggle('active', isActive);
            if (isActive && !wasActive) item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          });
        });

        let mobileControlsTimer = null;
        function showMobileControls() {
          mobileBtn.classList.add('show'); updateMobileIcon();
          clearTimeout(mobileControlsTimer);
          mobileControlsTimer = setTimeout(() => mobileBtn.classList.remove('show'), 3500);
        }

        mobileBtn.addEventListener('click', (e) => { e.stopPropagation(); togglePlay(); showFlash(!player.paused); showMobileControls(); });

        player.addEventListener('click', (e) => {
          const t = e.target;
          if (t.closest('.custom-actions') || t.closest('media-controls') || t.closest('button') || t.closest('[role="slider"]') || t.closest('media-menu') || t.closest('.mobile-play-btn') || t.closest('.side-panel')) return;
          if (isMobile()) { mobileBtn.classList.contains('show') ? (mobileBtn.classList.remove('show'), clearTimeout(mobileControlsTimer)) : showMobileControls(); }
          else { togglePlay(); requestAnimationFrame(() => showFlash(!player.paused)); }
        });

        document.addEventListener('keydown', (e) => {
          if (e.code === 'Space' && !e.target.matches('input, textarea, button, [contenteditable]')) { e.preventDefault(); togglePlay(); requestAnimationFrame(() => showFlash(!player.paused)); }
        });

        player.addEventListener('media-fullscreen-request', (e) => { e.preventDefault(); e.stopPropagation(); document.fullscreenElement ? document.exitFullscreen() : wrapper.requestFullscreen(); });

        // When entering/exiting fullscreen, re-inject our custom buttons (Vidstack may re-render controls)
        document.addEventListener('fullscreenchange', () => {
          if (!document.fullscreenElement && currentPanel) closePanel();
          setTimeout(() => {
            if (!player.querySelector('.custom-comments-btn')) interceptCommentsButton();
            const chapMenu = player.querySelector('.vds-chapters-menu media-menu-button');
            if (chapMenu && !chapMenu._chaptersIntercepted) interceptChaptersButton();
          }, 500);
        });

        // Autoplay only on desktop ‚Äî mobile browsers block it and it causes infinite loading
        if (!isMobile()) {
          player.play().catch(() => {});
        } else {
          // On mobile, switch to lighter loading strategy
          player.setAttribute('load', 'visible');
        }
      });
    });

    // ‚îÄ‚îÄ Data ‚îÄ‚îÄ
    let nextCommentsPageToken = null;
    let loadingComments = false;
    let allComments = []; // store for panel reuse

    // Recalculate all stem heights in a comment thread (called after Read more expand/collapse)
    function recalcStemHeights(el) {
      const thread = el.closest('.comment-thread');
      if (!thread) return;
      requestAnimationFrame(() => {
        // Main thread stem
        const threadStem = thread.querySelector(':scope > .thread-stem');
        if (threadStem && threadStem.style.height) {
          const repliesContainer = thread.querySelector(':scope > .replies-container');
          const topToggle = thread.querySelector(':scope > .replies-toggle-top');
          const target = (repliesContainer && repliesContainer.classList.contains('show')) ? repliesContainer : topToggle;
          if (target) {
            const threadRect = thread.getBoundingClientRect();
            const targetRect = target.getBoundingClientRect();
            threadStem.style.height = Math.max(0, targetRect.top - threadRect.top - 58 + 4) + 'px';
          }
        }
        // Sub-reply stems inside this thread
        thread.querySelectorAll('.reply-wrapper').forEach(wrapper => {
          const subStem = wrapper.querySelector(':scope > .subreply-stem');
          if (!subStem || !subStem.style.height) return;
          const subContainer = wrapper.querySelector(':scope > .subreplies-container');
          const subToggleTop = wrapper.querySelector(':scope > .subreply-toggle');
          const target = (subContainer && subContainer.classList.contains('show')) ? subContainer : subToggleTop;
          if (target) {
            const wrapperRect = wrapper.getBoundingClientRect();
            const targetRect = target.getBoundingClientRect();
            subStem.style.height = Math.max(0, targetRect.top - wrapperRect.top - 38 + 4) + 'px';
          }
        });
      });
    }

    async function loadVideoData() {
      try {
        const res = await fetch(`/api/video?id=${VIDEO_ID}`);
        if (!res.ok) return;
        const data = await res.json();

        document.getElementById('videoTitle').textContent = data.title;
        if (data.channelTitle) {
          document.getElementById('channelRow').style.display = 'flex';
          document.getElementById('channelName').textContent = data.channelTitle;
          if (data.channelAvatar) document.getElementById('channelAvatar').src = data.channelAvatar;
        }
        document.getElementById('descText').innerHTML = linkify(data.description || 'No description.');

        const count = data.commentCount ? Number(data.commentCount).toLocaleString() : '';
        document.getElementById('commentsHeading').textContent = count ? `Comments (${count})` : 'Comments';

        if (data.comments?.length) { allComments = data.comments; appendComments(data.comments, document.getElementById('commentsList')); }
        nextCommentsPageToken = data.nextPageToken;
        updateLoadMoreBtn();

        const chapters = parseChapters(data.description, parseDuration(data.duration));
        if (chapters.length > 0) {
          injectChapterTrack(chapters);
          renderChaptersPanel(chapters);
          renderMobileChapters(chapters);
          interceptChaptersButton();
        }
        // Comments button always injected (desktop only ‚Äî mobile has comments below)
        if (!isMobile()) interceptCommentsButton();
      } catch (err) { 
        console.error('Failed to load video data:', err);
        // Still inject comments button even if API fails
        if (!isMobile()) interceptCommentsButton();
      }
    }

    function appendComments(comments, container) {
      comments.forEach(c => {
        const thread = document.createElement('div');
        thread.className = 'comment-thread';
        let html = `<div class="comment-main">
          <img src="${c.avatar}" alt="" />
          <div class="comment-body">
            <div class="author">${escHtml(c.author)}</div>
            <div class="text truncated">${c.text}</div>
            <div class="meta">
              <span>${c.likes ? 'üëç ' + c.likes : ''}</span>
              <span>${timeAgo(c.date)}</span>
            </div>
          </div>
        </div>`;

        if (c.replyCount > 0) {
          html += `<div class="thread-stem"></div>`;
          html += `<button class="replies-toggle-top" data-comment-id="${c.id}">
            Show ${c.replyCount} ${c.replyCount === 1 ? 'reply' : 'replies'}
          </button>`;
          html += `<div class="replies-container" id="replies-${c.id}"></div>`;
        }

        thread.innerHTML = html;
        container.appendChild(thread);

        // Add "Read more" if text is truncated
        const textEl = thread.querySelector('.comment-main .text');
        if (textEl && textEl.scrollHeight > textEl.clientHeight + 2) {
          const btn = document.createElement('button');
          btn.className = 'read-more-btn';
          btn.textContent = 'Read more';
          btn.addEventListener('click', () => {
            const isExpanded = textEl.classList.contains('expanded');
            textEl.classList.toggle('expanded');
            btn.textContent = isExpanded ? 'Read more' : 'Show less';
            recalcStemHeights(textEl);
          });
          textEl.parentNode.insertBefore(btn, textEl.nextSibling);
        }

        if (c.replyCount > 0) {
          const topToggle = thread.querySelector('.replies-toggle-top');
          const repliesContainer = thread.querySelector('.replies-container');
          const threadStem = thread.querySelector('.thread-stem');
          // Mark thread as having replies (stem always visible)
          thread.classList.add('has-replies');
          // Bottom toggle lives INSIDE the replies-container (appended after tree is built)
          const bottomToggle = document.createElement('button');
          bottomToggle.className = 'replies-toggle-bottom';
          bottomToggle.dataset.commentId = c.id;
          bottomToggle.textContent = 'Hide replies';
          bottomToggle.style.display = 'none';
          repliesContainer.appendChild(bottomToggle);

          // Hover: highlight stem + collapse line together
          const hoverOn = () => thread.classList.add('thread-hover');
          const hoverOff = () => thread.classList.remove('thread-hover');
          threadStem.addEventListener('mouseenter', hoverOn);
          threadStem.addEventListener('mouseleave', hoverOff);

          const collapseReplies = () => {
            repliesContainer.classList.remove('show');
            thread.classList.remove('has-replies-open');
            topToggle.textContent = `Show ${c.replyCount} ${c.replyCount === 1 ? 'reply' : 'replies'}`;
            topToggle.style.display = '';
            bottomToggle.style.display = 'none';
            updateStemHeight();
          };

          const updateStemHeight = () => {
            requestAnimationFrame(() => {
              const threadRect = thread.getBoundingClientRect();
              // When expanded, stem reaches to the replies container; when collapsed, to the top toggle
              const target = repliesContainer.classList.contains('show') ? repliesContainer : topToggle;
              const targetRect = target.getBoundingClientRect();
              const stemHeight = targetRect.top - threadRect.top - 58 + 4;
              threadStem.style.height = Math.max(0, stemHeight) + 'px';
            });
          };

          // Click stem to toggle expand/collapse
          threadStem.addEventListener('click', () => {
            if (repliesContainer.classList.contains('show')) collapseReplies();
            else expandReplies();
          });

          const expandReplies = async () => {
            repliesContainer.classList.add('show');
            thread.classList.add('has-replies-open');
            topToggle.style.display = 'none';
            bottomToggle.style.display = '';

            if (!repliesContainer.querySelector('.reply-wrapper')) {
              topToggle.style.display = '';
              topToggle.disabled = true;
              topToggle.textContent = 'Loading...';
              bottomToggle.style.display = 'none';
              try {
                const res = await fetch(`/api/video?id=${VIDEO_ID}&replies=${c.id}`);
                const data = await res.json();
                if (data.replies?.length) {
                  buildReplyTree(data.replies, c.author, repliesContainer, collapseReplies);
                }
              } catch (err) { console.error('Failed to load replies:', err); }
              topToggle.disabled = false;
              topToggle.style.display = 'none';
              bottomToggle.style.display = '';
            }
            updateStemHeight();
          };

          topToggle.addEventListener('click', expandReplies);
          bottomToggle.addEventListener('click', collapseReplies);
          // Initial stem height (collapsed state ‚Äî stem to "Show X replies")
          requestAnimationFrame(() => updateStemHeight());
        }
      });
    }

    // Build a threaded reply tree with @mention-based nesting
    // Strips @mention from display text and nests under the mentioned person
    function buildReplyTree(replies, parentAuthor, container, collapseParent) {
      // Add a clickable collapse line running down the left side
      const collapseLine = document.createElement('div');
      collapseLine.className = 'replies-collapse-line';
      collapseLine.addEventListener('click', collapseParent);
      // Hover on collapse line highlights the stem too
      const parentThread = container.closest('.comment-thread');
      if (parentThread) {
        collapseLine.addEventListener('mouseenter', () => parentThread.classList.add('thread-hover'));
        collapseLine.addEventListener('mouseleave', () => parentThread.classList.remove('thread-hover'));
      }
      container.appendChild(collapseLine);

      // YouTube data: author names have @ prefix like "@oracleofwater"
      // textOriginal may start with "@username " (sometimes with zero-width chars before it)
      // Normalize: lowercase, strip @, strip zero-width chars
      const norm = s => s.toLowerCase().replace(/^@/, '').replace(/[\u200B-\u200D\uFEFF]/g, '').trim();

      const parsed = replies.map(r => {
        const orig = (r.textOriginal || '').replace(/^[\u200B-\u200D\uFEFF]+/, ''); // strip zero-width prefix
        let mentionedHandle = null;
        let cleanText = r.text;

        // textOriginal starts with @handle then space
        const m = orig.match(/^@(\S+)\s+/);
        if (m) {
          mentionedHandle = m[1]; // e.g. "oracleofwater" or "boohoo5419"
          // Strip the @mention from HTML display text (could be <a> wrapped, plain, or with zero-width chars)
          cleanText = r.text
            .replace(/^[\u200B-\u200D\uFEFF]*/, '')
            .replace(/^<a[^>]*>@[^<]*<\/a>\s*/, '')
            .replace(/^@\S+\s*/, '');
        }

        return { ...r, mentionedHandle, cleanText };
      });

      // Match a mentioned handle against an author name
      // Author: "@oracleofwater", handle from mention: "oracleofwater"
      const handleMatches = (handle, author) => {
        if (!handle || !author) return false;
        return norm(handle) === norm(author);
      };

      // Separate: direct replies (to parent or no mention) vs sub-replies
      const directReplies = [];
      const pendingSubs = [];

      parsed.forEach(r => {
        if (!r.mentionedHandle || handleMatches(r.mentionedHandle, parentAuthor)) {
          directReplies.push(r);
        } else {
          pendingSubs.push(r);
        }
      });

      // Attach sub-replies to the direct reply they mention
      // Use index-based mapping since the same author could appear multiple times
      const subRepliesByIdx = {};
      pendingSubs.forEach(r => {
        // Search backwards ‚Äî the 5th comment replying to the 2nd should find the 2nd
        let targetIdx = -1;
        for (let i = directReplies.length - 1; i >= 0; i--) {
          if (handleMatches(r.mentionedHandle, directReplies[i].author)) {
            targetIdx = i;
            break;
          }
        }
        if (targetIdx >= 0) {
          if (!subRepliesByIdx[targetIdx]) subRepliesByIdx[targetIdx] = [];
          subRepliesByIdx[targetIdx].push(r);
        } else {
          directReplies.push(r);
        }
      });

      directReplies.forEach((r, idx) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'reply-wrapper';
        const subs = subRepliesByIdx[idx] || [];

        const el = document.createElement('div');
        el.className = 'comment-main';
        el.innerHTML = `<img src="${r.avatar}" alt="" /><div class="comment-body"><div class="author">${escHtml(r.author)}</div><div class="text truncated">${r.cleanText}</div><div class="meta"><span>${r.likes ? 'üëç ' + r.likes : ''}</span><span>${timeAgo(r.date)}</span></div></div>`;
        wrapper.appendChild(el);
        // Add "Read more" for long replies
        requestAnimationFrame(() => {
          const textEl = el.querySelector('.text');
          if (textEl && textEl.scrollHeight > textEl.clientHeight + 2) {
            const btn = document.createElement('button');
            btn.className = 'read-more-btn';
            btn.textContent = 'Read more';
            btn.addEventListener('click', () => { textEl.classList.toggle('expanded'); btn.textContent = textEl.classList.contains('expanded') ? 'Show less' : 'Read more'; recalcStemHeights(textEl); });
            textEl.parentNode.insertBefore(btn, textEl.nextSibling);
          }
        });

        if (subs.length > 0) {
          // Stem line from this reply's avatar down to sub-replies
          const subStem = document.createElement('div');
          subStem.className = 'subreply-stem';
          wrapper.appendChild(subStem);
          // Always mark that this wrapper has sub-replies (stem always visible)
          wrapper.classList.add('has-subreplies');

          // Top toggle: "Show X Replies" ‚Äî visible when collapsed
          const subToggleTop = document.createElement('button');
          subToggleTop.className = 'subreply-toggle';
          subToggleTop.textContent = subs.length === 1 ? 'Show Reply' : `Show ${subs.length} Replies`;

          const subContainer = document.createElement('div');
          subContainer.className = 'subreplies-container';

          const subCollapseLine = document.createElement('div');
          subCollapseLine.className = 'subreplies-collapse-line';

          // Bottom toggle: "Hide Reply" ‚Äî visible when expanded, sits at end of sub-container
          // Use subreply-toggle-bottom class (no extra margin) since it's inside the indented container
          const subToggleBottom = document.createElement('button');
          subToggleBottom.className = 'subreply-toggle-bottom';
          subToggleBottom.style.display = 'none';
          subToggleBottom.textContent = subs.length === 1 ? 'Hide Reply' : 'Hide Replies';

          const updateSubStemHeight = () => {
            requestAnimationFrame(() => {
              const wrapperRect = wrapper.getBoundingClientRect();
              // When expanded, stem reaches to sub-container; when collapsed, to the top toggle
              const target = subContainer.classList.contains('show') ? subContainer : subToggleTop;
              const targetRect = target.getBoundingClientRect();
              const stemHeight = targetRect.top - wrapperRect.top - 38 + 4;
              subStem.style.height = Math.max(0, stemHeight) + 'px';
            });
          };

          const showSubs = () => {
            subContainer.classList.add('show');
            wrapper.classList.add('has-subreplies-open');
            subToggleTop.style.display = 'none';
            subToggleBottom.style.display = '';
            updateSubStemHeight();
          };
          const hideSubs = () => {
            subContainer.classList.remove('show');
            wrapper.classList.remove('has-subreplies-open');
            subToggleTop.style.display = '';
            subToggleTop.textContent = subs.length === 1 ? 'Show Reply' : `Show ${subs.length} Replies`;
            subToggleBottom.style.display = 'none';
            updateSubStemHeight();
          };

          // Hover: highlight sub-stem + sub-collapse line together
          const subHoverOn = () => wrapper.classList.add('subreply-hover');
          const subHoverOff = () => wrapper.classList.remove('subreply-hover');
          subStem.addEventListener('mouseenter', subHoverOn);
          subStem.addEventListener('mouseleave', subHoverOff);
          subCollapseLine.addEventListener('mouseenter', subHoverOn);
          subCollapseLine.addEventListener('mouseleave', subHoverOff);

          subCollapseLine.addEventListener('click', hideSubs);
          subStem.addEventListener('click', () => {
            if (subContainer.classList.contains('show')) hideSubs();
            else showSubs();
          });
          subContainer.appendChild(subCollapseLine);

          subs.forEach(sr => {
            const subItem = document.createElement('div');
            subItem.className = 'subreply-item';
            const subEl = document.createElement('div');
            subEl.className = 'comment-main';
            subEl.innerHTML = `<img src="${sr.avatar}" alt="" /><div class="comment-body"><div class="author">${escHtml(sr.author)}</div><div class="text truncated">${sr.cleanText}</div><div class="meta"><span>${sr.likes ? 'üëç ' + sr.likes : ''}</span><span>${timeAgo(sr.date)}</span></div></div>`;
            subItem.appendChild(subEl);
            subContainer.appendChild(subItem);
            // Add "Read more" for long sub-replies
            requestAnimationFrame(() => {
              const textEl = subEl.querySelector('.text');
              if (textEl && textEl.scrollHeight > textEl.clientHeight + 2) {
                const btn = document.createElement('button');
                btn.className = 'read-more-btn';
                btn.textContent = 'Read more';
                btn.addEventListener('click', () => { textEl.classList.toggle('expanded'); btn.textContent = textEl.classList.contains('expanded') ? 'Show less' : 'Read more'; recalcStemHeights(textEl); });
                textEl.parentNode.insertBefore(btn, textEl.nextSibling);
              }
            });
          });

          // Bottom toggle goes at the end of the sub-container
          subContainer.appendChild(subToggleBottom);

          subToggleTop.addEventListener('click', showSubs);
          subToggleBottom.addEventListener('click', hideSubs);
          wrapper.appendChild(subToggleTop);
          wrapper.appendChild(subContainer);
          // Initial stem height calculation (collapsed state ‚Äî stem to "Show Reply")
          requestAnimationFrame(() => updateSubStemHeight());
        }

        container.appendChild(wrapper);
      });

      // Move the bottom toggle to the very end of the container (after all reply-wrappers)
      const bottomToggle = container.querySelector('.replies-toggle-bottom');
      if (bottomToggle) container.appendChild(bottomToggle);
    }

    function populatePanelComments() {
      const container = document.getElementById('panelComments');
      container.innerHTML = '';
      // Reuse the same comment rendering ‚Äî panel uses slightly smaller sizes via panel-specific CSS
      allComments.forEach(c => {
        const thread = document.createElement('div');
        thread.className = 'comment-thread panel-thread';
        let html = `<div class="comment-main">
          <img src="${c.avatar}" alt="" />
          <div class="comment-body">
            <div class="author">${escHtml(c.author)}</div>
            <div class="text truncated">${c.text}</div>
            <div class="meta">${c.likes ? 'üëç ' + c.likes + ' ¬∑ ' : ''}${timeAgo(c.date)}</div>
          </div>
        </div>`;
        if (c.replyCount > 0) {
          html += `<div class="thread-stem"></div>`;
          html += `<button class="replies-toggle-top" data-comment-id="${c.id}">
            Show ${c.replyCount} ${c.replyCount === 1 ? 'reply' : 'replies'}
          </button>`;
          html += `<div class="replies-container" id="panel-replies-${c.id}"></div>`;
        }
        thread.innerHTML = html;
        container.appendChild(thread);

        // Add "Read more" for truncated panel comments
        const textEl = thread.querySelector('.comment-main .text');
        if (textEl) {
          requestAnimationFrame(() => {
            if (textEl.scrollHeight > textEl.clientHeight + 2) {
              const btn = document.createElement('button');
              btn.className = 'read-more-btn';
              btn.textContent = 'Read more';
              btn.addEventListener('click', () => { textEl.classList.toggle('expanded'); btn.textContent = textEl.classList.contains('expanded') ? 'Show less' : 'Read more'; recalcStemHeights(textEl); });
              textEl.parentNode.insertBefore(btn, textEl.nextSibling);
            }
          });
        }

        if (c.replyCount > 0) {
          const topToggle = thread.querySelector('.replies-toggle-top');
          const repliesContainer = thread.querySelector('.replies-container');
          const threadStem = thread.querySelector('.thread-stem');
          thread.classList.add('has-replies');
          const bottomToggle = document.createElement('button');
          bottomToggle.className = 'replies-toggle-bottom';
          bottomToggle.dataset.commentId = c.id;
          bottomToggle.textContent = 'Hide replies';
          bottomToggle.style.display = 'none';
          repliesContainer.appendChild(bottomToggle);

          // Hover wiring
          if (threadStem) {
            threadStem.addEventListener('mouseenter', () => thread.classList.add('thread-hover'));
            threadStem.addEventListener('mouseleave', () => thread.classList.remove('thread-hover'));
            threadStem.addEventListener('click', () => {
              if (repliesContainer.classList.contains('show')) collapseReplies();
              else expandReplies();
            });
          }

          const updatePanelStemHeight = () => {
            if (!threadStem) return;
            requestAnimationFrame(() => {
              const threadRect = thread.getBoundingClientRect();
              const target = repliesContainer.classList.contains('show') ? repliesContainer : topToggle;
              const targetRect = target.getBoundingClientRect();
              const stemHeight = targetRect.top - threadRect.top - 58 + 4;
              threadStem.style.height = Math.max(0, stemHeight) + 'px';
            });
          };

          const collapseReplies = () => {
            repliesContainer.classList.remove('show');
            thread.classList.remove('has-replies-open');
            topToggle.textContent = `Show ${c.replyCount} ${c.replyCount === 1 ? 'reply' : 'replies'}`;
            topToggle.style.display = '';
            bottomToggle.style.display = 'none';
            updatePanelStemHeight();
          };

          const expandReplies = async () => {
            repliesContainer.classList.add('show');
            thread.classList.add('has-replies-open');
            topToggle.style.display = 'none';
            bottomToggle.style.display = '';
            if (!repliesContainer.querySelector('.reply-wrapper')) {
              topToggle.style.display = '';
              topToggle.disabled = true;
              topToggle.textContent = 'Loading...';
              bottomToggle.style.display = 'none';
              try {
                const res = await fetch(`/api/video?id=${VIDEO_ID}&replies=${c.id}`);
                const data = await res.json();
                if (data.replies?.length) {
                  buildReplyTree(data.replies, c.author, repliesContainer, collapseReplies);
                }
              } catch (err) { console.error(err); }
              topToggle.disabled = false;
              topToggle.style.display = 'none';
              bottomToggle.style.display = '';
            }
            updatePanelStemHeight();
          };

          topToggle.addEventListener('click', expandReplies);
          bottomToggle.addEventListener('click', collapseReplies);
          requestAnimationFrame(() => updatePanelStemHeight());
        }
      });
    }

    function updateLoadMoreBtn() {
      let btn = document.getElementById('loadMoreBtn');
      if (nextCommentsPageToken) {
        if (!btn) { btn = document.createElement('button'); btn.id = 'loadMoreBtn'; btn.className = 'load-more-btn'; btn.textContent = 'Load more comments'; btn.addEventListener('click', loadMoreComments); document.getElementById('commentsList').after(btn); }
        btn.style.display = 'block';
      } else if (btn) { btn.style.display = 'none'; }
    }

    async function loadMoreComments() {
      if (loadingComments || !nextCommentsPageToken) return;
      loadingComments = true;
      const btn = document.getElementById('loadMoreBtn');
      if (btn) { btn.textContent = 'Loading...'; btn.disabled = true; }
      try {
        const res = await fetch(`/api/video?id=${VIDEO_ID}&commentsPage=${nextCommentsPageToken}`);
        if (!res.ok) return;
        const data = await res.json();
        if (data.comments?.length) { allComments.push(...data.comments); appendComments(data.comments, document.getElementById('commentsList')); }
        nextCommentsPageToken = data.nextPageToken;
        updateLoadMoreBtn();
      } catch (err) { console.error(err); }
      finally { loadingComments = false; if (btn) { btn.textContent = 'Load more comments'; btn.disabled = false; } }
    }

    window.addEventListener('scroll', () => {
      if (loadingComments || !nextCommentsPageToken) return;
      if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 400) loadMoreComments();
    });

    function linkify(text) {
      return escHtml(text).replace(/(https?:\/\/[^\s<]+)/g, '<a href="$1" target="_blank" rel="noopener">$1</a>').replace(/\n/g, '<br>');
    }

    function interceptChaptersButton() {
      // Intercept Vidstack's built-in chapters button: fix duplicate icon + redirect click to our panel
      customElements.whenDefined('media-player').then(() => {
        const player = document.querySelector('media-player');
        let attempts = 0;
        const poll = setInterval(() => {
          // Find the chapters media-menu
          const chaptersMenu = player.querySelector('.vds-chapters-menu') || 
            Array.from(player.querySelectorAll('media-menu')).find(m => m.querySelector('[class*="chapter"]'));
          if (!chaptersMenu) { if (++attempts > 50) clearInterval(poll); return; }
          
          const menuBtn = chaptersMenu.querySelector('media-menu-button');
          if (!menuBtn || menuBtn._chaptersIntercepted) { clearInterval(poll); return; }
          menuBtn._chaptersIntercepted = true;

          // Fix duplicate icon: strip all children and put a single clean icon
          menuBtn.innerHTML = '';
          const icon = document.createElement('div');
          icon.style.cssText = 'display:flex;align-items:center;justify-content:center;padding:7px;';
          icon.innerHTML = `<svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"/></svg>`;
          menuBtn.appendChild(icon);

          // Block the default menu open behavior, redirect to our side panel
          menuBtn.addEventListener('click', (e) => {
            e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
            // Force close any open menu
            chaptersMenu.removeAttribute('open');
            chaptersMenu.removeAttribute('data-open');
            openPanel('chapters');
          }, true);
          ['pointerdown','pointerup','mousedown','mouseup'].forEach(evt => {
            menuBtn.addEventListener(evt, (e) => { e.stopPropagation(); e.stopImmediatePropagation(); }, true);
          });

          clearInterval(poll);
        }, 200);
      });
    }

    function interceptCommentsButton() {
      // Inject a comments button into Vidstack's control bar next to the chapters button
      customElements.whenDefined('media-player').then(() => {
        const player = document.querySelector('media-player');
        let attempts = 0;
        const poll = setInterval(() => {
          // Look for the bottom controls group (contains fullscreen, pip, etc.)
          const groups = player.querySelectorAll('.vds-controls-group');
          if (!groups.length) { if (++attempts > 100) clearInterval(poll); return; }
          
          // Find the group that contains the fullscreen button (that's the bottom bar)
          let targetGroup = null;
          for (const g of groups) {
            if (g.querySelector('media-fullscreen-button') || g.querySelector('.vds-fullscreen-button')) {
              targetGroup = g;
              break;
            }
          }
          if (!targetGroup) targetGroup = groups[groups.length - 1];
          if (!targetGroup) { if (++attempts > 100) clearInterval(poll); return; }
          if (targetGroup.querySelector('.custom-comments-btn')) { clearInterval(poll); return; }

          const btn = document.createElement('button');
          btn.className = 'custom-comments-btn';
          btn.setAttribute('aria-label', 'Comments');
          btn.style.cssText = 'appearance:none;border:none;background:none;color:#fff;cursor:pointer;padding:7px;display:flex;align-items:center;opacity:0.8;transition:opacity 0.15s;';
          btn.innerHTML = `<svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>`;
          btn.addEventListener('mouseenter', () => btn.style.opacity = '1');
          btn.addEventListener('mouseleave', () => btn.style.opacity = '0.8');
          btn.addEventListener('click', (e) => { e.stopPropagation(); e.stopImmediatePropagation(); openPanel('comments'); }, true);
          ['pointerdown','pointerup','mousedown','mouseup'].forEach(evt => { btn.addEventListener(evt, (e) => { e.stopPropagation(); e.stopImmediatePropagation(); }, true); });

          // Insert before fullscreen button (only if it's a direct child of this group)
          const fsBtn = targetGroup.querySelector('media-fullscreen-button') || targetGroup.querySelector('.vds-fullscreen-button');
          if (fsBtn && fsBtn.parentNode === targetGroup) {
            targetGroup.insertBefore(btn, fsBtn);
          } else {
            targetGroup.appendChild(btn);
          }
          
          console.log('Comments button injected into control bar');
          clearInterval(poll);
        }, 300);
      });
    }

    function parseChapters(desc, totalDuration) {
      const regex = /^[\s]*(\d{1,2}:\d{2}(?::\d{2})?)\s*[-‚Äì‚Äî).\]]*\s*(.+)$/gm;
      const chapters = []; let match;
      while ((match = regex.exec(desc)) !== null) chapters.push({ time: match[1].trim(), label: match[2].trim(), seconds: timeToSeconds(match[1].trim()) });
      if (chapters.length < 3 || chapters[0].seconds !== 0) return [];
      for (let i = 0; i < chapters.length; i++) chapters[i].end = i < chapters.length - 1 ? chapters[i + 1].seconds : totalDuration;
      return chapters;
    }

    function renderChaptersPanel(chapters) {
      const list = document.getElementById('panelChapters');
      list.innerHTML = '';
      const thumb = `https://i.ytimg.com/vi/${VIDEO_ID}/mqdefault.jpg`;
      chapters.forEach(ch => {
        const item = document.createElement('div'); item.className = 'chapter-item'; item.dataset.start = ch.seconds; item.dataset.end = ch.end;
        item.innerHTML = `<img class="chapter-thumb" src="${thumb}" alt="" /><div class="chapter-info"><div class="chapter-label">${escHtml(ch.label)}</div><div class="chapter-time">${ch.time}</div></div>`;
        item.addEventListener('click', () => { const p = document.querySelector('media-player'); if (p) { p.currentTime = ch.seconds; p.play(); } });
        list.appendChild(item);
      });
    }

    function renderMobileChapters(chapters) {
      const list = document.getElementById('mobileChaptersList');
      if (!list) return;
      list.innerHTML = '';
      const thumb = `https://i.ytimg.com/vi/${VIDEO_ID}/mqdefault.jpg`;
      chapters.forEach(ch => {
        const chip = document.createElement('div');
        chip.className = 'mobile-chapter-chip';
        chip.dataset.start = ch.seconds;
        chip.dataset.end = ch.end;
        chip.innerHTML = `<img src="${thumb}" alt="" /><div class="chip-label">${escHtml(ch.label)}</div><div class="chip-time">${ch.time}</div>`;
        chip.addEventListener('click', () => { const p = document.querySelector('media-player'); if (p) { p.currentTime = ch.seconds; p.play(); } });
        list.appendChild(chip);
      });

      // Update active mobile chapter on timeupdate
      const player = document.querySelector('media-player');
      if (player) {
        player.addEventListener('timeupdate', () => {
          const time = player.currentTime;
          list.querySelectorAll('.mobile-chapter-chip').forEach(chip => {
            const start = parseFloat(chip.dataset.start), end = parseFloat(chip.dataset.end);
            const isActive = time >= start && time < end;
            chip.classList.toggle('active', isActive);
            if (isActive) chip.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
          });
        });
      }
    }

    function timeToSeconds(t) { const p = t.split(':').map(Number); return p.length === 3 ? p[0]*3600+p[1]*60+p[2] : p[0]*60+p[1]; }
    function parseDuration(iso) { const m = iso.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/); return m ? (parseInt(m[1]||0)*3600)+(parseInt(m[2]||0)*60)+parseInt(m[3]||0) : 0; }
    function pad(n) { return String(n).padStart(2,'0'); }
    function secsToVTT(s) { return `${pad(Math.floor(s/3600))}:${pad(Math.floor((s%3600)/60))}:${pad(Math.floor(s%60))}.000`; }

    function injectChapterTrack(chapters) {
      let vtt = 'WEBVTT\n\n';
      chapters.forEach(ch => { vtt += `${secsToVTT(ch.seconds)} --> ${secsToVTT(ch.end)}\n${ch.label}\n\n`; });
      const url = URL.createObjectURL(new Blob([vtt], { type: 'text/vtt' }));
      customElements.whenDefined('media-player').then(() => {
        const track = document.createElement('track'); track.kind = 'chapters'; track.src = url; track.default = true;
        document.querySelector('media-provider').appendChild(track);
      });
    }

    function escHtml(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }
    function timeAgo(dateStr) {
      const diff = Date.now() - new Date(dateStr).getTime(); const mins = Math.floor(diff/60000);
      if (mins < 60) return `${mins}m ago`; const hrs = Math.floor(mins/60);
      if (hrs < 24) return `${hrs}h ago`; const days = Math.floor(hrs/24);
      if (days < 30) return `${days}d ago`; const months = Math.floor(days/30);
      if (months < 12) return `${months}mo ago`; return `${Math.floor(months/12)}y ago`;
    }

    loadVideoData();
  </script>
